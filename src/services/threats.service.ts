// Threats Service

import apiService from './api';
import { API_ENDPOINTS } from '@/config/api';
import type { Threat, PaginatedResponse } from '@/types';

// Backend response format
interface BackendThreat {
  threat_id: string;
  asset_id: string;
  asset_name?: string;
  title: string;
  stride_category?: string;
  mitre_attack_id?: string;
  likelihood_score: number;
  impact_score: number;
  risk_score: number;
  status: string;
  auto_generated: boolean;
  created_at: string;
}

// Map backend threat to frontend format
const mapBackendThreat = (backendThreat: BackendThreat): Threat => {
  return {
    id: backendThreat.threat_id,
    title: backendThreat.title,
    assetId: backendThreat.asset_id,
    assetName: backendThreat.asset_name || 'Unknown Asset',
    strideCategory: backendThreat.stride_category as Threat['strideCategory'],
    mitreAttackId: backendThreat.mitre_attack_id,
    category: 'External', // Default - backend doesn't have this field
    likelihood: backendThreat.likelihood_score,
    impact: backendThreat.impact_score,
    riskScore: parseFloat(backendThreat.risk_score.toString()),
    status: backendThreat.status as Threat['status'],
    owner: '', // Will need to fetch owner separately
    ownerId: undefined,
    autoGenerated: backendThreat.auto_generated,
    createdAt: backendThreat.created_at,
    updatedAt: backendThreat.created_at, // Backend doesn't have updated_at yet
  };
};

export const threatsService = {
  getAll: async (params?: {
    page?: number;
    pageSize?: number;
    search?: string;
    status?: string;
    assetId?: string;
  }): Promise<PaginatedResponse<Threat>> => {
    const backendResponse = await apiService.getPaginated<BackendThreat>(
      API_ENDPOINTS.threats.list,
      {
        page: params?.page || 1,
        page_size: params?.pageSize || 50,
        search: params?.search,
        status: params?.status,
        asset_id: params?.assetId,
      }
    );

    const response = backendResponse as any;
    return {
      items: response.items.map(mapBackendThreat),
      total: response.total,
      page: response.page,
      pageSize: response.page_size || response.pageSize || 50,
      totalPages: response.total_pages || response.totalPages || 1,
    };
  },

  getById: async (id: string): Promise<Threat> => {
    const backendThreat = await apiService.get<BackendThreat>(API_ENDPOINTS.threats.detail(id));
    return mapBackendThreat(backendThreat);
  },

  create: async (data: Partial<Threat>): Promise<Threat> => {
    const backendData = {
      asset_id: data.assetId,
      title: data.title,
      stride_category: data.strideCategory,
      mitre_attack_id: data.mitreAttackId,
      likelihood_score: data.likelihood,
      impact_score: data.impact,
    };

    const backendThreat = await apiService.post<BackendThreat>(
      API_ENDPOINTS.threats.create,
      backendData
    );
    return mapBackendThreat(backendThreat);
  },

  update: async (id: string, data: Partial<Threat>): Promise<Threat> => {
    const backendData: any = {};
    if (data.title !== undefined) backendData.title = data.title;
    if (data.strideCategory !== undefined) backendData.stride_category = data.strideCategory;
    if (data.mitreAttackId !== undefined) backendData.mitre_attack_id = data.mitreAttackId;
    if (data.likelihood !== undefined) backendData.likelihood_score = data.likelihood;
    if (data.impact !== undefined) backendData.impact_score = data.impact;
    if (data.status !== undefined) backendData.status = data.status;

    const backendThreat = await apiService.patch<BackendThreat>(
      API_ENDPOINTS.threats.update(id),
      backendData
    );
    return mapBackendThreat(backendThreat);
  },

  transition: async (id: string, toState: Threat['status'], comment?: string): Promise<Threat> => {
    const backendThreat = await apiService.post<BackendThreat>(
      API_ENDPOINTS.threats.transition(id),
      { to_state: toState, comment }
    );
    return mapBackendThreat(backendThreat);
  },

  delete: async (id: string): Promise<void> => {
    return apiService.delete(API_ENDPOINTS.threats.delete(id));
  },

  getHistory: async (id: string): Promise<ThreatHistoryItem[]> => {
    const history = await apiService.get<ThreatHistoryItem[]>(API_ENDPOINTS.threats.history(id));
    return history;
  },

  // Threat Model Diagrams
  getDiagrams: async (params?: {
    page?: number;
    pageSize?: number;
    threatId?: string;
  }): Promise<PaginatedResponse<ThreatModelDiagram>> => {
    const queryParams: any = {
      page: params?.page || 1,
      page_size: params?.pageSize || 50,
    };
    
    // Only include threat_id if it's provided and not empty
    if (params?.threatId && params.threatId.trim() !== '') {
      queryParams.threat_id = params.threatId;
    }
    
    const response = await apiService.getPaginated<ThreatModelDiagram>(
      API_ENDPOINTS.threats.diagrams.list,
      queryParams
    );
    return response as any;
  },

  getDiagram: async (id: string): Promise<ThreatModelDiagram> => {
    return apiService.get<ThreatModelDiagram>(API_ENDPOINTS.threats.diagrams.detail(id));
  },

  createDiagram: async (data: ThreatModelDiagramCreate): Promise<ThreatModelDiagram> => {
    return apiService.post<ThreatModelDiagram>(API_ENDPOINTS.threats.diagrams.create, data);
  },

  updateDiagram: async (id: string, data: ThreatModelDiagramUpdate): Promise<ThreatModelDiagram> => {
    return apiService.put<ThreatModelDiagram>(API_ENDPOINTS.threats.diagrams.update(id), data);
  },

  deleteDiagram: async (id: string): Promise<void> => {
    return apiService.delete(API_ENDPOINTS.threats.diagrams.delete(id));
  },
};

export interface ThreatHistoryItem {
  history_id: string;
  threat_id: string;
  from_state: string;
  to_state: string;
  changed_by: string;
  changed_by_name: string;
  changed_at: string;
}

export interface ThreatModelDiagram {
  diagram_id: string;
  threat_id?: string;
  name: string;
  description?: string;
  canvas_data: {
    nodes: any[];
    links: any[];
  };
  created_by: string;
  created_at: string;
  updated_at: string;
  creator_name?: string;
}

export interface ThreatModelDiagramCreate {
  name: string;
  description?: string;
  threat_id?: string;
  canvas_data: {
    nodes: any[];
    links: any[];
  };
}

export interface ThreatModelDiagramUpdate {
  name?: string;
  description?: string;
  canvas_data?: {
    nodes: any[];
    links: any[];
  };
}

